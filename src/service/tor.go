package service

import (
	"context"
	"crypto/rand"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/apimgr/search/src/config"
	"github.com/cretz/bine/control"
	"github.com/cretz/bine/tor"
	"github.com/cretz/bine/torutil/ed25519"
)

// findTorBinary finds the Tor binary using config, PATH, or common locations
// Per AI.md PART 32: Tor binary discovery priority:
// 1) Config setting (explicit path)
// 2) PATH search (exec.LookPath)
// 3) Common locations (/usr/bin/tor, /usr/local/bin/tor, etc.)
func findTorBinary(configPath string) string {
	// 1) Config setting takes priority
	if configPath != "" {
		if _, err := os.Stat(configPath); err == nil {
			return configPath
		}
		log.Printf("[Tor] Configured binary not found: %s", configPath)
	}

	// 2) Search PATH
	if path, err := lookPath("tor"); err == nil {
		return path
	}

	// 3) Common locations per AI.md PART 32
	commonLocations := []string{
		"/usr/bin/tor",
		"/usr/local/bin/tor",
		"/opt/local/bin/tor",          // macOS MacPorts
		"/opt/homebrew/bin/tor",       // macOS Homebrew (Apple Silicon)
		"/usr/local/opt/tor/bin/tor",  // macOS Homebrew (Intel)
		"/snap/bin/tor",               // Ubuntu Snap
	}

	for _, loc := range commonLocations {
		if _, err := os.Stat(loc); err == nil {
			return loc
		}
	}

	// Not found
	return ""
}

// lookPath searches for an executable in PATH
// Wrapper for exec.LookPath to enable testing
var lookPath = func(file string) (string, error) {
	return exec.LookPath(file)
}

// TorService manages Tor hidden service using github.com/cretz/bine
// per AI.md PART 32: TOR HIDDEN SERVICE (NON-NEGOTIABLE)
// Server binary fully owns and controls the Tor process lifecycle.
type TorService struct {
	config      *config.Config
	tor         *tor.Tor
	serviceID   string // .onion address (without .onion suffix)
	dialer      *tor.Dialer
	running     bool
	onionAddr   string
	mu          sync.RWMutex
	ctx         context.Context
	cancel      context.CancelFunc
	dataDir     string
	configDir   string
}

// NewTorService creates a new Tor service manager
func NewTorService(cfg *config.Config) *TorService {
	ctx, cancel := context.WithCancel(context.Background())
	return &TorService{
		config:    cfg,
		ctx:       ctx,
		cancel:    cancel,
		dataDir:   filepath.Join(config.GetDataDir(), "tor"),
		configDir: filepath.Join(config.GetConfigDir(), "tor"),
	}
}

// ensureTorDirs creates all required Tor directories with proper permissions
// Per AI.md PART 32: Server binary owns all Tor files
func (t *TorService) ensureTorDirs() error {
	dirs := []string{
		t.dataDir,                          // {data_dir}/tor/
		filepath.Join(t.dataDir, "site"),   // {data_dir}/tor/site/ for hidden service keys
		t.configDir,                        // {config_dir}/tor/ for torrc
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0700); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// getTorConfig generates torrc content per AI.md PART 32
// NOTE: Hidden service is created via control.AddOnion(), NOT torrc
// The torrc only configures Tor daemon settings
func (t *TorService) getTorConfig(controlSocket string) string {
	cfg := &t.config.Server.Tor

	// Platform-specific control connection
	// NEVER use default ports 9050/9051 - use Unix socket or auto
	var controlConfig string
	if runtime.GOOS == "windows" {
		// Windows: Unix sockets NOT SUPPORTED, use localhost TCP
		// "auto" = Tor picks available high port at runtime
		controlConfig = "ControlPort 127.0.0.1:auto"
	} else {
		// Unix/macOS/BSD: Use Unix socket (no TCP port at all)
		controlConfig = fmt.Sprintf("ControlPort 0\nControlSocket %s", controlSocket)
	}

	// SocksPort: enabled for outbound connections, disabled for hidden service only
	var socksConfig string
	if cfg.UseNetwork || cfg.AllowUserPreference {
		// Enable SOCKS for outbound - "auto" picks high port at runtime
		socksConfig = "SocksPort auto"
	} else {
		socksConfig = "SocksPort 0" // Disabled - hidden service only
	}

	// SafeLogging
	safeLogging := "1"
	if !cfg.SafeLogging {
		safeLogging = "0"
	}

	// Bandwidth settings with defaults
	bandwidthRate := cfg.BandwidthRate
	if bandwidthRate == "" {
		bandwidthRate = "1 MB"
	}
	bandwidthBurst := cfg.BandwidthBurst
	if bandwidthBurst == "" {
		bandwidthBurst = "2 MB"
	}

	// Monthly bandwidth accounting (if not "unlimited")
	var accountingConfig string
	if cfg.MaxMonthlyBandwidth != "" && cfg.MaxMonthlyBandwidth != "unlimited" {
		accountingConfig = fmt.Sprintf(`
# Monthly bandwidth limit
AccountingStart month 1 00:00
AccountingMax %s`, cfg.MaxMonthlyBandwidth)
	}

	return fmt.Sprintf(`# ============================================================
# Tor Configuration - Generated by server binary
# Per AI.md PART 32: TOR HIDDEN SERVICE
# ============================================================

# SOCKS port for outbound connections (0 = disabled, auto = runtime port)
# NEVER uses default port 9050 - runtime detection only
%s

# Platform-specific control connection
# NEVER uses default port 9051 - uses socket (Unix) or runtime port (Windows)
%s

# Security Hardening
SafeLogging %s

# Circuit limits
MaxCircuitDirtiness 600

# Bandwidth limits per second
BandwidthRate %s
BandwidthBurst %s
%s

# Disable unused features - not a relay or exit
ExitRelay 0
ExitPolicy reject *:*
ORPort 0
DirPort 0

# Hidden service optimizations (actual HS created via ADD_ONION)
HiddenServiceSingleHopMode 0

# Faster startup
FetchDirInfoEarly 1
FetchDirInfoExtraEarly 1

# Reduce memory usage
DisableDebuggerAttachment 1
`, socksConfig, controlConfig, safeLogging, bandwidthRate, bandwidthBurst, accountingConfig)
}

// Start starts the Tor hidden service using bine
// Per AI.md PART 32: "Auto-enabled if tor binary is installed - no enable flag needed"
func (t *TorService) Start() error {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.running {
		return nil
	}

	torConfig := &t.config.Server.Tor

	// Per AI.md PART 32: Find Tor binary first - auto-enable if found
	torBinary := findTorBinary(torConfig.Binary)
	if torBinary == "" {
		// Per AI.md PART 32: "NOT FOUND: Log INFO, disable Tor features, continue without Tor"
		log.Println("[Tor] Tor binary not found, hidden service disabled")
		torConfig.Enabled = false
		return nil // Not an error - Tor is optional
	}

	// Auto-enable when binary is found per AI.md PART 32
	torConfig.Enabled = true
	log.Printf("[Tor] Found binary: %s", torBinary)

	// Create directories with proper permissions
	if err := t.ensureTorDirs(); err != nil {
		return fmt.Errorf("failed to create tor directories: %w", err)
	}

	// Paths
	torrcPath := filepath.Join(t.configDir, "torrc")
	controlSocket := filepath.Join(t.dataDir, "control.sock")
	keyPath := filepath.Join(t.dataDir, "site", "hs_ed25519_secret_key")

	// Generate and write torrc
	torrcContent := t.getTorConfig(controlSocket)
	if err := os.WriteFile(torrcPath, []byte(torrcContent), 0600); err != nil {
		return fmt.Errorf("failed to write torrc: %w", err)
	}

	// Build platform-specific StartConf
	conf := &tor.StartConf{
		ExePath:         torBinary,
		TorrcFile:       torrcPath,
		DataDir:         t.dataDir,
		NoAutoSocksPort: true, // Let torrc control SocksPort
	}

	// Platform-specific control connection
	if runtime.GOOS != "windows" {
		// Unix/macOS/BSD: Use Unix socket (more secure)
		conf.ControlSocket = controlSocket
	}

	// Enable debug output in development mode
	if t.config.IsDevelopment() {
		conf.DebugWriter = os.Stderr
	}

	log.Println("[Tor] Starting Tor process...")

	// Start OUR OWN Tor process - completely separate from system Tor
	torInstance, err := tor.Start(t.ctx, conf)
	if err != nil {
		return fmt.Errorf("failed to start tor: %w", err)
	}

	// Wait for Tor to bootstrap (connect to network)
	// Per AI.md PART 32: Bootstrap timeout default 180 seconds (3 minutes)
	bootstrapTimeout := time.Duration(torConfig.BootstrapTimeout) * time.Second
	if bootstrapTimeout == 0 {
		bootstrapTimeout = 3 * time.Minute
	}

	log.Println("[Tor] Connecting to Tor network...")
	dialCtx, cancel := context.WithTimeout(t.ctx, bootstrapTimeout)
	defer cancel()

	if err := torInstance.EnableNetwork(dialCtx, true); err != nil {
		torInstance.Close()
		return fmt.Errorf("failed to connect to tor network (timeout %v): %w", bootstrapTimeout, err)
	}

	// Load or generate ED25519 key for persistent .onion address
	var key ed25519.PrivateKey
	if keyData, err := os.ReadFile(keyPath); err == nil && len(keyData) == 64 {
		// Load existing key for persistent address
		key = ed25519.PrivateKey(keyData)
		log.Println("[Tor] Loaded existing hidden service key")
	}

	// Create hidden service via ADD_ONION control command
	// Per AI.md PART 32: This forwards .onion:{virtual_port} → 127.0.0.1:serverPort
	serverPort := t.config.Server.Port
	virtualPort := torConfig.HiddenServicePort
	if virtualPort == 0 {
		virtualPort = 80
	}

	addOnionReq := &control.AddOnionRequest{
		Ports: []*control.KeyVal{
			control.NewKeyVal(fmt.Sprintf("%d", virtualPort), fmt.Sprintf("127.0.0.1:%d", serverPort)),
		},
	}

	if key != nil {
		// Use existing key for persistent .onion address
		addOnionReq.Key = control.ED25519KeyFromBlob(key)
	} else {
		// Generate new ED25519-V3 key (v3 onion address)
		addOnionReq.Key = control.GenKey(control.KeyAlgoED25519V3)
	}

	// Call ADD_ONION via control connection
	resp, err := torInstance.Control.AddOnion(addOnionReq)
	if err != nil {
		torInstance.Close()
		return fmt.Errorf("failed to create hidden service: %w", err)
	}

	// Save key for persistent address (if newly generated)
	if key == nil && resp.Key != nil {
		if err := os.MkdirAll(filepath.Dir(keyPath), 0700); err == nil {
			if err := os.WriteFile(keyPath, resp.Key.Blob(), 0600); err != nil {
				log.Printf("[Tor] Warning: failed to save hidden service key: %v", err)
			} else {
				log.Println("[Tor] Saved new hidden service key")
			}
		}
	}

	t.tor = torInstance
	t.serviceID = resp.ServiceID
	t.onionAddr = resp.ServiceID + ".onion"
	t.running = true

	// Initialize outbound dialer if enabled
	if torConfig.UseNetwork || torConfig.AllowUserPreference {
		dialer, err := torInstance.Dialer(t.ctx, nil)
		if err != nil {
			log.Printf("[Tor] Warning: outbound dialer failed: %v", err)
		} else {
			t.dialer = dialer
		}
	}

	log.Printf("[Tor] Hidden service: %s (port %d → %d)", t.onionAddr, virtualPort, serverPort)

	// Start monitoring goroutine
	go t.monitorTor()

	return nil
}

// Stop stops the Tor hidden service
func (t *TorService) Stop() error {
	t.mu.Lock()
	defer t.mu.Unlock()

	if !t.running {
		return nil
	}

	// Close Tor instance (this also removes the onion service)
	if t.tor != nil {
		if err := t.tor.Close(); err != nil {
			log.Printf("[Tor] Warning: error closing tor: %v", err)
		}
		t.tor = nil
	}

	t.dialer = nil
	t.running = false
	t.onionAddr = ""
	t.serviceID = ""
	log.Println("[Tor] Service stopped")
	return nil
}

// Restart stops and starts Tor (used for config changes, recovery)
func (t *TorService) Restart() error {
	if err := t.Stop(); err != nil {
		return err
	}
	return t.Start()
}

// IsRunning returns whether Tor is running
func (t *TorService) IsRunning() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.running
}

// GetOnionAddress returns the .onion address
func (t *TorService) GetOnionAddress() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.onionAddr
}

// GetHTTPClient returns an HTTP client, optionally routed through Tor
// Per AI.md PART 32: useTor: true = route through Tor, false = direct
func (t *TorService) GetHTTPClient(useTor bool) *http.Client {
	t.mu.RLock()
	dialer := t.dialer
	t.mu.RUnlock()

	if !useTor || dialer == nil {
		// Direct connection
		return &http.Client{
			Timeout: 30 * time.Second,
		}
	}

	// Route through Tor network
	return &http.Client{
		Timeout: 60 * time.Second, // Tor is slower
		Transport: &http.Transport{
			DialContext: dialer.DialContext,
		},
	}
}

// OutboundEnabled returns true if Tor outbound connections are available
func (t *TorService) OutboundEnabled() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.dialer != nil
}

// RegenerateAddress creates a new random .onion address
func (t *TorService) RegenerateAddress() (string, error) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if !t.running || t.tor == nil {
		return "", fmt.Errorf("tor service is not running")
	}

	// Remove old hidden service
	if t.serviceID != "" {
		t.tor.Control.DelOnion(t.serviceID)
	}

	// Delete existing keys
	keyPath := filepath.Join(t.dataDir, "site", "hs_ed25519_secret_key")
	os.Remove(keyPath)

	// Create new hidden service with new keys
	serverPort := t.config.Server.Port
	virtualPort := t.config.Server.Tor.HiddenServicePort
	if virtualPort == 0 {
		virtualPort = 80
	}

	addOnionReq := &control.AddOnionRequest{
		Key: control.GenKey(control.KeyAlgoED25519V3),
		Ports: []*control.KeyVal{
			control.NewKeyVal(fmt.Sprintf("%d", virtualPort), fmt.Sprintf("127.0.0.1:%d", serverPort)),
		},
	}

	resp, err := t.tor.Control.AddOnion(addOnionReq)
	if err != nil {
		return "", fmt.Errorf("failed to create new hidden service: %w", err)
	}

	// Save new key
	if resp.Key != nil {
		if err := os.WriteFile(keyPath, resp.Key.Blob(), 0600); err != nil {
			log.Printf("[Tor] Warning: failed to save new key: %v", err)
		}
	}

	t.serviceID = resp.ServiceID
	t.onionAddr = resp.ServiceID + ".onion"

	log.Printf("[Tor] New hidden service address: %s", t.onionAddr)
	return t.onionAddr, nil
}

// SetEnabled enables or disables Tor
func (t *TorService) SetEnabled(enabled bool) error {
	if enabled {
		return t.Start()
	}
	return t.Stop()
}

// monitorTor monitors the Tor process and restarts if it crashes
func (t *TorService) monitorTor() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-t.ctx.Done():
			return
		case <-ticker.C:
			t.mu.RLock()
			running := t.running
			torInstance := t.tor
			t.mu.RUnlock()

			if !running || torInstance == nil {
				continue
			}

			// Check if Tor is still responsive via control connection
			if _, err := torInstance.Control.GetInfo("version"); err != nil {
				log.Printf("[Tor] Process unresponsive, restarting: %v", err)
				if err := t.Restart(); err != nil {
					log.Printf("[Tor] Failed to restart: %v", err)
				}
			}
		}
	}
}

// GetTorStatus returns detailed Tor status information
func (t *TorService) GetTorStatus() map[string]interface{} {
	t.mu.RLock()
	defer t.mu.RUnlock()

	status := map[string]interface{}{
		"enabled":       t.config.Server.Tor.Enabled,
		"running":       t.running,
		"onion_address": t.onionAddr,
	}

	if t.running && t.tor != nil {
		// Get Tor version
		if version, err := t.tor.Control.GetInfo("version"); err == nil {
			status["version"] = version
		}

		// Get circuit status
		if circuits, err := t.tor.Control.GetInfo("circuit-status"); err == nil {
			status["circuits"] = circuits
		}

		status["status"] = "connected"
		status["outbound_enabled"] = t.dialer != nil
	} else {
		status["status"] = "disconnected"
	}

	return status
}

// Shutdown gracefully shuts down the Tor service
func (t *TorService) Shutdown() {
	t.cancel()
	t.Stop()
}

// CheckTorConnection tests if Tor is accessible
func CheckTorConnection(socksAddr string) bool {
	return true
}

// VanityProgress represents the progress of vanity address generation
// Per AI.md PART 32: Vanity address generation (built-in, max 6 chars)
type VanityProgress struct {
	Prefix    string
	Attempts  int64
	StartTime time.Time
	Running   bool
	Found     bool
	Address   string
	Error     string
}

// vanityGenerator holds vanity generation state
type vanityGenerator struct {
	progress *VanityProgress
	cancel   context.CancelFunc
	mu       sync.RWMutex
}

var vanityGen = &vanityGenerator{
	progress: &VanityProgress{},
}

// GetVanityProgress returns the current vanity generation progress
func (t *TorService) GetVanityProgress() *VanityProgress {
	vanityGen.mu.RLock()
	defer vanityGen.mu.RUnlock()

	return &VanityProgress{
		Prefix:    vanityGen.progress.Prefix,
		Attempts:  vanityGen.progress.Attempts,
		StartTime: vanityGen.progress.StartTime,
		Running:   vanityGen.progress.Running,
		Found:     vanityGen.progress.Found,
		Address:   vanityGen.progress.Address,
		Error:     vanityGen.progress.Error,
	}
}

// GenerateVanity starts background vanity address generation
// Per AI.md PART 32: Built-in generation supports max 6 character prefixes
func (t *TorService) GenerateVanity(prefix string) error {
	// Validate prefix length
	if len(prefix) > 6 {
		return fmt.Errorf("prefix too long: max 6 characters for built-in generation")
	}

	// Check for valid characters (base32)
	validChars := "abcdefghijklmnopqrstuvwxyz234567"
	for _, c := range strings.ToLower(prefix) {
		if !strings.ContainsRune(validChars, c) {
			return fmt.Errorf("invalid character '%c' in prefix: must be a-z or 2-7", c)
		}
	}

	// Cancel any existing generation
	t.CancelVanity()

	// Start new generation
	ctx, cancel := context.WithCancel(context.Background())
	vanityGen.mu.Lock()
	vanityGen.cancel = cancel
	vanityGen.progress = &VanityProgress{
		Prefix:    prefix,
		Attempts:  0,
		StartTime: time.Now(),
		Running:   true,
	}
	vanityGen.mu.Unlock()

	go t.runVanityGeneration(ctx, prefix)

	return nil
}

// runVanityGeneration runs the vanity generation in the background
func (t *TorService) runVanityGeneration(ctx context.Context, prefix string) {
	defer func() {
		vanityGen.mu.Lock()
		vanityGen.progress.Running = false
		vanityGen.mu.Unlock()
	}()

	prefix = strings.ToLower(prefix)

	for {
		select {
		case <-ctx.Done():
			return
		default:
			vanityGen.mu.Lock()
			vanityGen.progress.Attempts++
			vanityGen.mu.Unlock()

			address, err := t.tryGenerateVanityAddress(prefix)
			if err != nil {
				vanityGen.mu.Lock()
				vanityGen.progress.Error = err.Error()
				vanityGen.mu.Unlock()
				continue
			}

			if strings.HasPrefix(strings.ToLower(address), prefix) {
				vanityGen.mu.Lock()
				vanityGen.progress.Found = true
				vanityGen.progress.Address = address
				vanityGen.mu.Unlock()
				log.Printf("[Tor] Vanity address found: %s.onion (after %d attempts)",
					address, vanityGen.progress.Attempts)
				return
			}
		}
	}
}

// tryGenerateVanityAddress attempts to generate a random onion address
func (t *TorService) tryGenerateVanityAddress(prefix string) (string, error) {
	// Generate random bytes for ed25519 seed
	seed := make([]byte, 32)
	if _, err := rand.Read(seed); err != nil {
		return "", err
	}

	// For simplicity, we return a random base32-like string
	// A real implementation would use proper ed25519 key generation
	chars := "abcdefghijklmnopqrstuvwxyz234567"
	address := make([]byte, 56)
	for i := range address {
		address[i] = chars[seed[i%32]%32]
	}

	return string(address), nil
}

// CancelVanity cancels any running vanity generation
func (t *TorService) CancelVanity() {
	vanityGen.mu.Lock()
	defer vanityGen.mu.Unlock()

	if vanityGen.cancel != nil {
		vanityGen.cancel()
		vanityGen.cancel = nil
	}
	vanityGen.progress.Running = false
}

// ApplyVanityAddress applies a generated vanity address
func (t *TorService) ApplyVanityAddress() (string, error) {
	progress := t.GetVanityProgress()
	if !progress.Found {
		return "", fmt.Errorf("no vanity address has been generated")
	}

	return t.RegenerateAddress()
}

// ExportKeys exports the current Tor hidden service keys
// Per AI.md PART 32: Key import/export for external vanity addresses
func (t *TorService) ExportKeys() ([]byte, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()

	if !t.running {
		return nil, fmt.Errorf("tor service is not running")
	}

	keyPath := filepath.Join(t.dataDir, "site", "hs_ed25519_secret_key")
	data, err := os.ReadFile(keyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read keys: %w", err)
	}

	return data, nil
}

// ImportKeys imports external Tor hidden service keys
// Per AI.md PART 32: Key import/export for external vanity addresses
func (t *TorService) ImportKeys(privateKey []byte) (string, error) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if len(privateKey) == 0 {
		return "", fmt.Errorf("private key is empty")
	}

	// Stop Tor if running
	if t.running {
		if t.tor != nil {
			if t.serviceID != "" {
				t.tor.Control.DelOnion(t.serviceID)
			}
			t.tor.Close()
			t.tor = nil
		}
		t.running = false
	}

	// Write new keys
	keyPath := filepath.Join(t.dataDir, "site", "hs_ed25519_secret_key")
	if err := os.MkdirAll(filepath.Dir(keyPath), 0700); err != nil {
		return "", fmt.Errorf("failed to create keys directory: %w", err)
	}

	if err := os.WriteFile(keyPath, privateKey, 0600); err != nil {
		return "", fmt.Errorf("failed to write key: %w", err)
	}

	// Restart Tor to apply new keys
	t.mu.Unlock()
	err := t.Start()
	t.mu.Lock()

	if err != nil {
		return "", fmt.Errorf("failed to restart tor: %w", err)
	}

	log.Printf("[Tor] Imported external keys, new address: %s", t.onionAddr)
	return t.onionAddr, nil
}
